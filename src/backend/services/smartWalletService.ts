import { v4 as uuidv4 } from 'uuid';
import { supabase } from '../lib/db';
import { SmartWallet } from '../../common/types/database.types';
import { ApiError } from '../lib/apiError';

// This is a server-side service that will interact with the Coinbase Wallet SDK
export class SmartWalletService {
  static NETWORK_ID = 'base-sepolia'; // Network ID for testnet

  /**
   * Creates a smart wallet for a vendor
   * 
   * Note: This will be called during the signup process.
   * In a production environment, this would interact with a frontend component
   * that uses the Coinbase Wallet SDK to create the wallet.
   * 
   * For this implementation, we're creating a mock smart wallet with a placeholder address,
   * but in production, you would use the client-side SDK to create the wallet.
   * 
   * @param userId Vendor's user ID
   * @returns The created smart wallet
   */
  static async createSmartWalletForVendor(userId: string): Promise<SmartWallet> {
    try {
      // Check if user already has a wallet
      const { data: existingWallet } = await supabase
        .from('smart_wallets')
        .select('*')
        .eq('user_id', userId)
        .single();

      if (existingWallet) {
        return existingWallet as SmartWallet;
      }

      // In a real implementation, you would:
      // 1. Redirect the user to a page where they can create a smart wallet using the SDK
      // 2. Use the connector to create the wallet: await cbWalletConnector.connect()
      // 3. Get the wallet address from the connection
      
      // For now, we'll create a mock wallet with a placeholder address
      const mockAddress = `0x${Math.random().toString(16).slice(2, 42)}`;
      
      // Store wallet details in database
      const walletData = {
        id: uuidv4(),
        user_id: userId,
        wallet_address: mockAddress,
        network_id: this.NETWORK_ID,
        is_platform_created: true,
        created_at: new Date(),
        updated_at: new Date(),
      };

      const { data, error } = await supabase
        .from('smart_wallets')
        .insert(walletData)
        .select()
        .single();

      if (error) {
        console.error('Error storing smart wallet:', error);
        throw new ApiError('Failed to store wallet details', 500, error.message);
      }

      return data as SmartWallet;
    } catch (error) {
      console.error('Error creating smart wallet:', error);
      throw new ApiError('Failed to create vendor wallet', 500, error instanceof Error ? error.message : undefined);
    }
  }

  /**
   * Gets a vendor's smart wallet details
   * 
   * @param userId Vendor's user ID
   * @returns The smart wallet or null if not found
   */
  static async getVendorSmartWallet(userId: string): Promise<SmartWallet | null> {
    const { data, error } = await supabase
      .from('smart_wallets')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error) {
      if (error.code === 'PGRST116') { // Record not found
        return null;
      }
      throw new ApiError('Failed to fetch vendor wallet', 500, error.message);
    }

    return data as SmartWallet;
  }


  /**
   * Gets the smart wallet status for a vendor.
   *
   * @param vendorUserId Vendor's user ID
   * @returns Object indicating if a wallet exists and the wallet address if it does.
   */
  static async getVendorSmartWalletStatus(vendorUserId: string): Promise<{ hasWallet: boolean; walletAddress?: string | null }> {
    const { data, error } = await supabase
      .from('smart_wallets')
      .select('wallet_address')
      .eq('user_id', vendorUserId)
      .single();

    if (error && error.code !== 'PGRST116') { // PGRST116 means no rows found, which is not an error here
      console.error('Error fetching vendor smart wallet status:', error);
      throw new ApiError('Failed to fetch vendor smart wallet status', 500, error.message);
    }

    if (data && data.wallet_address) {
      return { hasWallet: true, walletAddress: data.wallet_address };
    }

    return { hasWallet: false };
  }

  /**
   * Registers a client-generated smart wallet for a vendor.
   *
   * @param vendorUserId Vendor's user ID
   * @param walletAddress The address of the smart wallet generated by the client SDK
   * @param networkId The network ID for the wallet
   * @returns The created smart wallet record
   */
  static async registerVendorSmartWallet(vendorUserId: string, walletAddress: string, networkId?: string): Promise<SmartWallet> {
    try {
      // Check if user already has a wallet registered with this address or another
      const { data: existingWallet, error: existingWalletError } = await supabase
        .from('smart_wallets')
        .select('*')
        .eq('user_id', vendorUserId)
        .maybeSingle();

      if (existingWalletError && existingWalletError.code !== 'PGRST116') {
        console.error('Error checking for existing smart wallet:', existingWalletError);
        throw new ApiError('Failed to check for existing smart wallet', 500, existingWalletError.message);
      }
      
      if (existingWallet) {
        // If a wallet exists for this user already, decide on behavior:
        // Option 1: Throw error - "User already has a smart wallet."
        // Option 2: Update existing record if address is different (less likely for this flow)
        // Option 3: Return existing record if address matches
        if (existingWallet.wallet_address === walletAddress) {
          return existingWallet as SmartWallet;
        }
        // For now, let's throw an error if a different wallet is already registered.
        // This flow assumes one smart wallet per vendor, created once.
        throw new ApiError('Vendor already has a different smart wallet registered.', 409);
      }

      // Store wallet details in database
      const walletData = {
        id: uuidv4(),
        user_id: vendorUserId,
        wallet_address: walletAddress,
        network_id: networkId || this.NETWORK_ID,
        is_platform_created: true, // Assuming this flow means platform initiated the creation process
        created_at: new Date(),
        updated_at: new Date(),
      };

      const { data, error } = await supabase
        .from('smart_wallets')
        .insert(walletData)
        .select()
        .single();

      if (error) {
        console.error('Error storing smart wallet:', error);
        // Handle potential duplicate wallet address across users if wallet_address needs to be globally unique
        if (error.code === '23505') { // Unique constraint violation
             throw new ApiError('This smart wallet address is already registered by another user.', 409, error.message);
        }
        throw new ApiError('Failed to store smart wallet details', 500, error.message);
      }

      return data as SmartWallet;
    } catch (error) {
      console.error('Error registering smart wallet:', error);
      if (error instanceof ApiError) throw error;
      throw new ApiError('Failed to register vendor smart wallet', 500, error instanceof Error ? error.message : undefined);
    }
  }
} 